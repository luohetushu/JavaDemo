面向对象简称 OO（Object Oriented)
面向对象程序设计优点:
1、可重用性：代码重复使用，减少代码量，提高开发效率。
2、可扩展性：指新的功能可以很容易地加入到系统中来，便于软件的修改。
3、可管理性：能够将功能与数据结合，方便管理
面向对象核心特性：
1、继承：继承性是指子类拥有父类的全部特征和行为，这是类之间的一种关系。 Java 只支持单继承
2、封装：封装的目的在于保护信息   Java 语言的基本封装单位是类。
保护类中的信息，阻止在外部定义的代码随意访问内部代码和数据。
隐藏细节信息，一些不需要程序员修改和使用的信息
建立各个系统之间的松耦合关系，提高系统的独立性
提高软件的复用率，降低成本。每个系统都是一个相对独立的整体，可以在不同的环境中得到使用
Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户可以访问的东西，私有的方法数据只能通过该类的成员代码来访问
3、多态：即“一个接口，多个方法”，多态性允许一个接口被多个同类使用
多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。

类是对象的抽象，对象是类的具体
类是描述了一组有相同特性（属性）和相同行为（方法）的一组对象的集合：
1、对象或实体所拥有的特征在类中表示时称为类的属性
2、对象执行的操作称为类的方法



类是构造面向对象程序的基本单位
类的定义：使用 class 关键字、一个自定义的类名和一对表示程序体的大括号
[public] [abstract|final] class <class_name> [extends<class_name>] [implements<interface_name>] {
    // 定义属性部分
    <property_type><property1>;
    <property_type><property2>;
    <property_type><property3>;
    …
    // 定义方法部分
    function1();
    function2();
    function3();
    …
}
public：表示“共有”的意思。如果使用 public 修饰，则可以被其他类和程序访问。每个 Java 程序的主类都必须是 public 类，
abstract：如果类被 abstract 修饰，则该类为抽象类，抽象类不能被实例化，但抽象类中可以有抽象方法（使用 abstract 修饰的方法）
         和具体方法（没有使用 abstract 修饰的方法）。继承该抽象类的所有子类都必须实现该抽象类中的所有抽象方法（除非子类也是抽象类）。
final：如果类被 final 修饰，则不允许被继承。
class：声明类的关键字。
class_name：类的名称。类名以下划线（_）或字母开头，不能包含除了下划线（_）和美元符号（$）字符之外的特殊字符
extends：表示继承其他类。
implements：表示实现某些接口。
property_type：表示成员变量的类型。
property：表示成员变量名称。
function()：表示成员方法名称

定义类的属性：
[public|protected|private] [static] [final] <type> <variable_name>
public、protected、private：用于表示成员变量的访问权限。
static：表示该成员变量为类变量，也称为静态变量。
final：表示将该成员变量声明为常量，其值无法更改。
type：表示变量的类型。
variable_name：表示变量名称
可以在声明成员变量的同时对其进行初始化，如果声明成员变量时没有对其初始化，则系统会使用默认值初始化成员变量。
初始化的默认值如下：
整数型（byte、short、int 和 long）的基本类型变量的默认值为 0。
单精度浮点型（float）的基本类型变量的默认值为 0.0f。
双精度浮点型（double）的基本类型变量的默认值为 0.0d。
字符型（char）的基本类型变量的默认值为 “\u0000”。
布尔型的基本类型变量的默认值为 false。
数组引用类型的变量的默认值为 null。如果创建了数组变量的实例，但没有显式地为每个元素赋值，则数组中的元素初始化值采用数组数据类型对应的默认值。

定义类的方法：一个完整的方法通常包括方法名称、方法主体、方法参数和方法返回值类型
[public|private|protected] [static] <void|return_type> <method_name> ([paramList]) {
        // 方法体
}
public、private、protected：表示成员方法的访问权限。
static：表示限定该成员方法为静态方法。
final：表示限定该成员方法不能被重写或重载。
abstract：表示限定该成员方法为抽象方法。抽象方法不提供具体的实现，并且所属类型必须为抽象类

this 关键字是 Java 常用的关键字，可用于任何实例方法内指向当前对象，也可指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用
this( )访问构造方法：
this( ) 不能在普通方法中使用，只能写在构造方法中。
在构造方法中使用时，必须是第一条语句



对象
显示创建对象：
1. 使用 new 关键字创建对象  类名 对象名 = new 类名()；
2. 调用 java.lang.Class 或者 java.lang.reflect.Constructor 类的 newInstance() 实例方法
java.lang.Class Class 类对象名称 = java.lang.Class.forName(要实例化的类全称);
类名 对象名 = (类名)Class类对象名称.newInstance();
3. 调用对象的 clone() 方法
该方法不常用，使用该方法创建对象时，要实例化的类必须继承 java.lang.Cloneable 接口
类名对象名 = (类名)已创建好的类对象名.clone();
4. 调用 java.io.ObjectInputStream 对象的 readObject() 方法

隐含创建对象

无论釆用哪种方式创建对象，Java 虚拟机在创建一个对象时都包含以下步骤：
1、给对象分配内存。
2、将对象的实例变量自动初始化为其变量类型的默认值。
3、初始化对象，给实例变量赋予正确的初始值
每个对象都是相互独立的，在内存中占有独立的内存地址，并且每个对象都具有自己的生命周期，当一个对象的生命周期结束时，对象就变成了垃圾，由 Java 虚拟机自带的垃圾回收机制处理
在 Java 的 Object 类中还提供了一个 protected 类型的 finalize() 方法，因此任何 Java 类都可以覆盖这个方法，在这个方法中进行释放对象所占有的相关资源的操作。

垃圾回收（Garbage Collection）机制，简称 GC
在 Java 虚拟机的堆区，每个对象都可能处于以下三种状态之一：
1）可触及状态：当一个对象被创建后，只要程序中还有引用变量引用它，那么它就始终处于可触及状态。
2）可复活状态：当程序不再有任何引用变量引用该对象时，该对象就进入可复活状态。
在这个状态下，垃圾回收器会准备释放它所占用的内存，
在释放之前，会调用它及其他处于可复活状态的对象的 finalize() 方法，这些 finalize() 方法有可能使该对象重新转到可触及状态。
3）不可触及状态：当 Java 虚拟机执行完所有可复活对象的 finalize() 方法后，如果这些方法都没有使该对象转到可触及状态，垃圾回收器才会真正回收它占用的内存。

注意：调用 System.gc() 或者 Runtime.gc() 方法也不能保证回收操作一定执行，它只是提高了 Java 垃圾回收器尽快回收垃圾的可能性



访问控制修饰符
访问控制符是一组限定类、属性或方法是否可以被程序里的其他部分访问和调用的修饰符。
类的访问控制符只能是空或者 public，
方法和属性的访问控制符有 4 个，分别是 public、 private、protected 和 friendly，其中 friendly 是一种没有定义专门的访问控制符的默认情况
访问范围     	private	friendly(默认)	protected	public
同一个类	        可访问	可访问	        可访问	    可访问
同一包中的其他类	不可访问	可访问	        可访问	    可访问
不同包中的子类	不可访问	不可访问	        可访问	    可访问
不同包中的非子类	不可访问	不可访问	        不可访问	    可访问
1. private
用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类）访问和引用
2. friendly（默认）   这种访问特性又称为包访问性（package private）
如果一个类没有访问控制符，说明它具有默认的访问控制特性。
这种默认的访问控制权规定，该类只能被同一个包中的类访问和引用，而不能被其他包中的类使用，即使其他包中有该类的子类。
类内的成员如果没有访问控制符，也说明它们具有包访问性，或称为友元（friend）
3. protected
用保护访问控制符 protected 修饰的类成员可以被三种类所访问：该类自身、与它在同一个包中的其他类以及在其他包中的该类的子类
4. public
当一个类被声明为 public 时，它就具有了被其他包中的类访问的可能性，只要包中的其他类在程序中使用 import 语句引入 public 类，就可以访问和引用这个类



静态修饰符static
静态成员：使用 static 修饰符修饰的属性（成员变量）、常量和成员方法称为静态变量、常量和方法
类的成员变量：静态变量（或称为类变量），指被 static 修饰的成员变量；实例变量，指没有被 static 修饰的成员变量。
静态变量：运行时，Java 虚拟机只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配。
        在类的内部，可以在任何方法内直接访问静态变量；在其他类中，可以通过类名访问该类中的静态变量。
        静态变量可以被类的所有实例共享，共有属性
        如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间
实例变量：每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。
        在类的内部，可以在非静态方法中直接访问实例变量；在本类的静态方法或其他类中则需要通过类的实例对象进行访问

类的成员方法：静态方法（或称为类方法），指被 static 修饰的成员方法；实例方法，指没有被 static 修饰的成员方法
在访问非静态方法时，需要通过实例对象来访问，而在访问静态方法时，可以直接访问，也可以通过类名来访问，还可以通过实例化对象来访问
静态方法：不需要通过它所属的类的任何实例就可以被调用，因此在静态方法中不能使用 this 关键字，也不能直接访问所属类的实例变量和实例方法，
        但是可以直接访问所属类的静态变量和静态方法。
        另外，和 this 关键字一样，super 关键字也与类的特定实例相关，所以在静态方法中也不能使用 super 关键字。
实例方法：可以直接访问所属类的静态变量、静态方法、实例变量和实例方法

静态代码块
静态代码块指 Java 类中的 static{} 代码块，主要用于初始化类，为类的静态变量赋初始值
1、静态代码块类似于一个方法，但它不可以存在于任何方法体中。
2、Java 虚拟机在加载类时会执行静态代码块，如果类中包含多个静态代码块，则 Java 虚拟机将按它们在类中出现的顺序依次执行它们，每个静态代码块只会被执行一次。
   分主类静态代码块与其主类代码块，主类静态代码块在主方法main之前执行
3、静态代码块与静态方法一样，不能直接访问类的实例变量和实例方法，而需要通过类的实例对象来访问

构造代码块，一般用于非主类中，在构造方法之前执行，且每次实例化皆会调用




final修饰符
final 关键字表示对象是最终形态的，对象是不可改变的
1. final 修饰类中的属性
表示该属性一旦被初始化便不可改变，对基本类型来说是其值不可变，而对对象属性来说其引用不可再变
2. final 修饰类中的方法
说明这种方法提供的功能已经满足当前要求，不需要进行扩展，并且也不允许任何从此类继承的类来重写这种方法，
但是继承仍然可以继承这个方法，也就是说可以直接使用。在声明类中，一个 final 方法只被实现一次
3. final 修饰类
表示该类是无法被任何其他类继承的，意味着此类在一个继承树中是一个叶子类，并且此类的设计已被认为很完美而不需要进行修改或扩展



方法的可变参数:
methodName({paramList}, paramType… paramName)
methodName 表示方法名称；paramList 表示方法的固定参数列表；paramType 表示可变参数的类型；… 是声明可变参数的标识；paramName 表示可变参数名称
注：可变参数必须定义在参数列表的最后



构造方法
构造方法是类的一种特殊方法，用来初始化类的一个新的对象，在创建对象（new 运算符）之后自动调用
Java 构造方法有以下特点：
1、方法名必须与类名相同
2、可以有 0 个、1 个或多个参数
3、没有任何返回值，包括 void
4、默认返回类型就是对象类型本身
5、只能与 new 运算符结合使用



析构方法与构造方法相反，当对象脱离其作用域时（例如对象所在的方法已调用完毕），系统自动执行析构方法
析构方法往往用来做清理垃圾碎片的工作，例如在建立对象时用 new 开辟了一片内存空间，应退出前在析构方法中将其释放。

在 Java 的 Object 类中还提供了一个 protected 类型的 finalize() 方法，在这个方法中进行释放对象所占有的相关资源的操作。

对象的 finalize() 方法具有如下特点：
1、垃圾回收器是否会执行该方法以及何时执行该方法，都是不确定的。
2、finalize() 方法有可能使用对象复活，使对象恢复到可触及状态。
3、垃圾回收器在执行 finalize() 方法时，如果出现异常，垃圾回收器不会报告异常，程序继续正常运行
注：由于 finalize() 方法的不确定性，所以在程序中可以调用 System.gc() 或者 Runtime.gc() 方法提示垃圾回收器尽快执行垃圾回收操作



Java中常用的系统包:
java.lang	            Java 的核心类库，包含运行 Java 程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、异常处理和线程类等，
                        系统默认加载这个包
java.io	                Java语言的标准输入/输出类库，如基本输入/输出流、文件输入/输出、过滤输入/输出流等
java.util	            包含如处理时间的 Date 类，处理动态数组的 Vector 类，以及 Stack 和 HashTable 类
java.awt	            构建图形用户界面（GUI）的类库，低级绘图操作 Graphics 类、图形界面组件和布局管理
                       （如 Checkbox 类、Container 类、LayoutManger 接口等），以及用户界面交互控制和事件响应（如 Event 类）
java.awt.image	        处理和操纵来自网上的图片的 Java 工具类库
java.wat.peer	        很少在程序中直接用到，使得同一个 Java 程序在不同的软硬件平台上运行
java.net	            实现网络功能的类库有 Socket 类、ServerSocket 类
java.lang.reflect	    提供用于反射对象的工具
java.util.zip	        实现文件压缩功能
java.awt.datatransfer	处理数据传输的工具类，包括剪贴板、字符串发送器等
java.sql	            实现 JDBC 的类库
java.rmi	            提供远程连接与载入的支持
java.security	        提供安全性方面的有关支持




