类的封装
封装就是将对象的属性和方法相结合，通过方法将对象的属性和实现细节保护起来，实现对象的属性隐藏。
修改属性的可见性来限制对属性的访问，并为每个属性创建一对取值（getter）方法和赋值（setter）方法，用于对这些属性的访问
封装的具体步骤：
1、修改属性的可见性来限制对属性的访问。
2、为每个属性创建一对赋值方法和取值方法，用于对这些属性的访问。
3、在赋值和取值方法中，加入对属性的存取限制



类的继承
class class_name extends extend_class
{
    //类的主体
}
子类在进行实例化时，系统会默认进行父类的实例化操作
注：类的继承并不改变类成员的访问权限。如果父类的成员是公有的、被保护的或默认的，它的子类仍具有相应的这些特性
注：如果在父类中存在有参的构造方法而并没有重载无参的构造方法，那么在子类中必须含有有参的构造方法。
   如果在子类中不含有构造方法，默认会调用父类中无参的构造方法，而在父类中并没有无参的构造方法，故出错
注：Java 不支持多继承，只允许一个类直接继承另一个类，即子类只能有一个父类，extends 关键字后面只能有一个类名
注：如果类声明头部没有定义任何 extends 子句，则该类隐含地继承自 java.lang.Object 类

super关键字：super调用父类的构造方法、利用super访问父类成员
使用 super 关键字：
1、在类的构造方法中，通过 super 语句调用该类的父类的构造方法。
   要调用父类的构造方法，必须在子类的构造方法体的第一行使用 super() 方法。该方法会调用父类相应的构造方法来完成子类对象的初始化工作。
   注：super() 必须是在子类构造方法的主体第一行
   注：super 用来直接调用父类中的构造方法，使用它可以使书写代码更简洁方便
2、在子类中访问父类中的成员
   super.member //父类中的方法或属性名称
   this.member  //子类中的方法或属性名称
   其中，member 是父类中的方法或属性名称。多用于子类的成员名隐藏了父类中的同名成员的情况
   注：super 还可以用于调用被子类隐藏的方法



对象类型转换和强制对象类型转换
eg：class Father{}
    class Child1 extends Father{}
某个类型的引用变量可以引用子类的实例，然后可以对这个引用变量进行类型转换：
向下转型：把引用类型转换为子类类型
向上转型：把引用类型转换为父类类型，使得接收或返回参数的统一性  Father fat = new Child1();
注：Java 编译器允许在具有直接或间接继承关系的类之间进行类型转换。对于向下转型，必须进行强制类型转换；对于向上转型，不必使用强制类型转换
注：向下转型之前，首先发生向上转型
   错误：Father fat = new Father();  // 不转型
        Child1 chd1 = (Child1) fat; // 向下转型  ClassCastException
   正确：Father fat = new Child1();  // 向上转型
        Child1 chd1 = (Child1) fat; // 向下转型
注：在向下转型之前，进行 instanceof 判断  关键字instanceof：对象 instanceof 类  对象是否属于某一类
        Father fat = new Child1();  // 向上转型
        if (fat instanceof Child1){  // true
            Child1 chd1 = (Child1) fat; // 向下转型
        }



通过引用类型变量来访问所引用对象的属性和方法时，Java 虚拟机做绑定规则：
1、实例方法与引用变量实际引用的对象的方法进行绑定，这种绑定属于动态绑定，因为是在运行时由 Java 虚拟机动态决定的。
2、静态方法与引用变量所声明的类型的方法绑定，这种绑定属于静态绑定，因为是在编译阶段已经做了绑定。
3、成员变量（包括静态变量和实例变量）与引用变量所声明的类型的成员变量绑定，这种绑定属于静态绑定，因为在编译阶段已经做了绑定。



方法重载Overloading：
同一个类中的两个或多个方法可以共享同一个名称，只须它们的参数声明不同
分 普通方法的重载 和 构造方法的重载
注：重载方法的参数列表必须和被重载的方法不同，并且这种不同必须足以清楚地确定要调用哪一个方法。
   重载方法的返回值类型可以和被重载的方法相同，也可以不同，但是只有返回值类型不同不能表示为重载



方法重写Override，又称方法覆盖：
在子类中创建父类中相同名称、相同返回值类型、相同参数列表的方法，只是方法体中的实现不同，以实现不同于父类的功能
在重写方法时，遵循以下规则：
1、参数列表必须完全与被重写的方法参数列表相同，否则不能称其为重写。
2、返回的类型必须与被重写的方法的返回类型相同，否则不能称其为重写。
3、访问修饰符的限制一定要大于被重写方法的访问修饰符（public > protected > default > private）。
4、重写方法一定不能抛出新的检査异常或者比被重写方法声明更加宽泛的检査型异常。
   例如，父类的一个方法声明了一个检査异常 IOException，在重写这个方法时就不能抛出 Exception，只能拋出 IOException 的子类异常，可以抛出非检査异常
5、重写方法返回值范围小于等于父类

变量隐藏：子类中创建的成员变量，其类型和名称都与父类中的同名成员变量相同


final 修饰的类叫最终类，该类不能被继承。
final 修饰的方法不能被重写。
final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改


多态性：
指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为
对面向对象来说，多态分：
1、编译时多态：编译时多态是静态的，主要是指方法的重载，根据参数列表的不同来区分不同的方法。通过编译之后会变成两个不同的方法
2、运行时多态：运行时多态是动态的，通过动态绑定来实现的

实现多态必要条件：继承、重写和向上转型
1、继承：在多态中必须存在有继承关系的子类和父类。
2、重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
3、向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法



抽象（abstract）类
<abstract> class <class_name>
{
    <abstract> <type> <method_name> (parameter-list);
}
abstract 表示该类或该方法是抽象的；class_name 表示抽象类的名称；method_name 表示抽象方法名称，parameter-list 表示方法参数列表
注：如果在一个方法之前使用 abstract 来修饰，则说明该方法是抽象方法，不能有方法体；
注：abstract 关键字只能用于普通方法，不能用于 static 方法或者构造方法中。
注：在抽象类中的抽象方法不能有具体的实现，而应在它们的子类中实现所有的抽象方法（要有方法体）
注：抽象类不一定非要有抽象方法
   abstract class Cat {
       public void sayHi() {
           System.out.println("hi~");
       }
       public static Cat getInstance(){
           return new Tiger();
       }
   }
   class Tiger extends Cat{}
注：任何使用 new 创建抽象类对象的尝试都会导致编译时错误，抽象类无法实例化
    抽象类的对象可以用子类的向上转型实现: Cat cat = new Tiger();
    static 方法永远不受任何的结构约束，可以使用类名称直接调用：Cat cat = Cat.getInstance();

接口
[public] interface interface_name [extends interface1_name[, interface2_name,…]]
{
    //接口体，其中可以包含定义常量和声明方法
    [public] [static] [final] type constant_name=value;    //定义常量
    [public] [abstract] returnType method_name(parameter_list);    //声明方法
}
public 表示接口的修饰符，当没有修饰符时，则使用默认的修饰符，此时该接口的访问权限仅局限于所属的包；
interface_name 表示接口的名称，可以是任何有效的标识符；extends 表示接口的继承关系；interface1_name 表示要继承的接口名称；
constant_name 表示变量名称，一般是 static 和 final 型的；
returnType 表示方法的返回值类型；parameter_list 表示参数列表，在接口中的方法是没有方法体的

接口的特征：
1、具有 public 访问控制符的接口，允许任何类使用；没有指定 public 的接口，其访问将局限于所属的包。
2、方法的声明不需要其他修饰符，在接口中声明的方法，将隐式地声明为公有的（public）和抽象的（abstract）。
3、在 Java 接口中声明的变量其实都是常量，接口中的变量声明，将隐式地声明为 public、static 和 final，即常量，所以接口中定义的变量必须初始化。
4、接口没有构造方法，不能被实例化
5、一个接口不能够实现另一个接口，但它可以继承多个其他接口。子接口可以对父接口的方法和常量进行重写

实现接口的方法必须声明为 public，而且实现方法的类型必须严格与接口定义中指定的类型相匹配



内部类
内部类拥有外围类的所有元素的访问权限：轻松访问外部类私有属性
内部类可以分为：成员内部类（实例内部类、静态内部类）和 局部内部类

内部类的特点：
1、内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的 .class 文件，但是前面冠以外部类的类名和 $ 符号。
2、内部类不能用普通的方式访问。内部类是外部类的一个成员，因此内部类可以自由地访问外部类的成员变量，无论是否为 private 的。
3、内部类声明成静态的，就不能随便访问外部类的成员变量，只能访问外部类的静态成员变量
注：内部抽象类或内部接口类，不受外部类（普通类、抽象类、接口）限制，可以在其他地方直接继承或实现

实例内部类：没有用 static 修饰的内部类
public class Outer
{
    class Inner
    {
        //实例内部类
    }
} //内部类编译后，生成Outer$Inner.class字节码文件
实例内部类特点：
1、在外部类的静态方法和外部类以外的其他类中，必须通过外部类的实例创建内部类的实例
内部类实例化对象格式：Outer.Inner i = new Outer().new Inner();    //需要创建外部类实例
2、在实例内部类中，可以访问外部类的所有成员
如果有多层嵌套，则内部类可以访问所有外部类的成员
3、在外部类中不能直接访问内部类的成员，而必须通过内部类的实例去访问。
如果类 A 包含内部类 B，类 B 中包含内部类 C，则在类 A 中不能直接访问类 C，而应该通过类 B 的实例去访问类 C
4、外部类实例与内部类实例是一对多的关系，也就是说一个内部类实例只对应一个外部类实例，而一个外部类实例则可以对应多个内部类实例。
如果实例内部类 B 与外部类 A 包含有同名的成员 t，则在类 B 中 t 和 this.t 都表示 B 中的成员 t，而 A.this.t 表示 A 中的成员 t
5、在实例内部类中不能定义 static 成员，除非同时使用 final 和 static 修饰

静态内部类：指使用 static 修饰的内部类
public class Outer
{
    int a=0;    //实例变量
    static int b=0;    //静态变量

    static class Inner
    {
        //静态内部类
        int a=0;    //实例变量a
        static int b=0;    //静态变量 b

        Outer o = new Outer();
        int a2 = o.a;    //访问实例变量
        int b2 = b;    //访问静态变量
        int b3 = Outer.b;    //访问外部类静态变量
    }
}
静态内部类特点：
1、在创建静态内部类的实例时，不需要创建外部类的实例
Outer.Inner oi = new Outer.Inner();
2、静态内部类中可以定义静态成员和实例成员。
外部类以外的其他类需要通过完整的类名访问静态内部类中的静态成员，
int a2=oi.a;    //访问实例成员
如果要访问静态内部类中的实例成员，则需要通过静态内部类的实例
int b2=Outer.Inner.b;    //访问静态成员
3、静态内部类可以直接访问外部类的静态成员，如果要访问外部类的实例成员，则需要通过外部类的实例去访问

局部内部类：指在一个方法中定义的内部类
public class Outer
{
    public void method()
    {
        class Inner
        {
            //局部内部类
        }
    }
}
局部内部类特点：
1、局部内部类与局部变量一样，不能使用访问控制修饰符（public、private 和 protected）和 static 修饰符修饰
2、局部内部类只在当前方法中有效
3、局部内部类中不能定义 static 成员。
4、局部内部类中还可以包含内部类，但是这些内部类也不能使用访问控制修饰符（public、 private 和 protected）和 static 修饰符修饰。
5、在局部内部类中可以访问外部类的所有成员
6、在局部内部类中只可以访问当前方法中的所有成员。
如果方法中的成员与外部类中的成员同名，则可以使用 <OuterClassName>.this.<MemberName> 的形式访问外部类中的成员

匿名类：是指没有类名的内部类，必须在创建时使用 new 语句来声明类
new<类或接口>()
{
    //类的主体     对一个给定的类进行扩展，或者实现一个给定的接口。使用匿名类可使代码更加简洁、紧凑，模块化程度更高
};
匿名类实现方式：
1、继承一个类，重写其方法。
2、实现一个接口（可以是多个），实现其方法
匿名类特点：
1、匿名类和局部内部类一样，可以访问外部类的所有成员
2、匿名类中允许使用非静态代码块进行成员初始化操作
3、匿名类的非静态代码块会在父类的构造方法之后被执行




