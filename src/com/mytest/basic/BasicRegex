正则表达式（Regular Expression）:
由普通的字符（如字符 a~z）以及特殊字符（元字符）组成的文字模式,对字符串进行查找、提取、分割、替换等操作，
一种可以用于模式匹配和替换的规范,任意字符串都可以当成正则表达式使用

String 类对正则的支持：
boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。
String replaceAll(String regex, String replacement)：将该字符串中所有匹配 regex 的子串替换成 replacement。
String replaceFirst(String regex, String replacement)：将该字符串中第一个匹配 regex 的子串替换成 replacement。
String[] split(String regex)：以 regex 作为分隔符，把该字符串分割成多个子串
String[] split(String regex, int limit)：以 regex 作为分隔符，把该字符串分割成指定个数子串

正则表达式支持字符：
X	    字符x（x 可代表任何合法的字符)
\0mnn	八进制数 0mnn 所表示的字符
\xhh	十六进制值 0xhh 所表示的字符
\uhhhh	十六进制值 0xhhhh 所表示的 Unicode 字符         所有中文字符的 Unicode 值是连续
\t	    制表符（“\u0009”）
\n	    新行（换行）符（‘\u000A’）
\r	    回车符（‘\u000D’)
\f 	    换页符（‘\u000C’）
\a	    报警（bell）符（‘\u0007’）
\e	    Escape 符（‘\u001B’）
\cx	    x 对应的的控制符。例如，\cM匹配 Ctrl-M。x 值必须为 A~Z 或 a~z 之一

正则表达式特殊字符：
$	匹配一行的结尾。要匹配 $ 字符本身，请使用\$
^	匹配一行的开头。要匹配 ^ 字符本身，请使用\^
()	标记子表达式的开始和结束位置。要匹配这些字符，请使用\(和\)
[]	用于确定中括号表达式的开始和结束位置。要匹配这些字符，请使用\[和\]
{}	用于标记前面子表达式的出现频度。要匹配这些字符，请使用\{和\}
*	指定前面子表达式可以出现零次或多次。要匹配 * 字符本身，请使用\*
+	指定前面子表达式可以出现一次或多次。要匹配 + 字符本身，请使用\+
?	指定前面子表达式可以出现零次或一次。要匹配 ？字符本身，请使用\?
.	匹配除换行符\n之外的任何单字符。要匹配.字符本身，请使用\.
\	用于转义下一个字符，或指定八进制、十六进制字符。如果需匹配\字符，请用\\
|	指定两项之间任选一项。如果要匹配丨字符本身，请使用\|
eg："\u0041\\\\" // 匹配 A\        Java 字符串中反斜杠本身需要转义，因此两个反斜杠（\\）实际上相当于一个（前一个用于转义）
   "\u0061\t"  // 匹配a<制表符>
   "\\?\\["    // 匹配？[

正则表达式预定义字符：
.	可以匹配任何字符
\d	匹配 0~9 的所有数字  digit
\D	匹配非数字
\s	匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等  space
\S	匹配所有的非空白字符
\w	匹配所有的单词字符，包括 0~9 所有数字、26 个英文字母和下画线_  word
\W	匹配所有的非单词字符
eg：c\\wt    // 可以匹配cat、cbt、cct、cOt、c9t等一批字符串
   \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d    // 匹配如 000-000-0000 形式的电话号码

正则表达式方括号表达式：
表示枚举	        例如[abc]表示 a、b、c 其中任意一个字符；[gz]表示 g、z 其中任意一个字符
表示范围：-	    例如[a-f]表示 a~f 范围内的任意字符；[\\u0041-\\u0056]表示十六进制字符 \u0041 到 \u0056 范围的字符。
                    范围可以和枚举结合使用，如[a-cx-z]，表示 a~c、x~z 范围内的任意字符
表示求否：^	    例如[^abc]表示非 a、b、c 的任意字符；[^a-f]表示不是 a~f 范围内的任意字符
表示“与”运算：&&	例如[a-z&&[def]]是 a~z 和 [def] 的交集，表示 d、e、f
                   [a-z&&^bc]]是 a~z 范围内的所有字符，除 b 和 c 之外[ad-z]
                   [a-z&&[m-p]]是 a~z 和 m~p 的交集
表示“并”运算	    例如[a-d[m-p]]表示 [a-dm-p]

正则表达式边界匹配符：
^	行的开头
$	行的结尾
\b	单词的边界
\B	非单词的边界
\A	输入的开头
\G	前一个匹配的结尾
\Z	输入的结尾，仅用于最后的结束符
\z	输入的结尾

正则表达式数量标识符：
Greedy（贪婪模式）：数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。
Reluctant（勉强模式）：用问号后缀（?）表示，它只会匹配最少的字符。也称为最小匹配模式。
Possessive（占有模式）：用加号后缀（+）表示，目前只有 Java 支持占有模式，通常比较少用
贪婪模式	勉强模式	占用模式	说明
X?	    X??	    X?+	    X表达式出现零次或一次
X*	    X*?	    X*+	    X表达式出现零次或多次
X+	    X+?	    X++	    X表达式出现一次或多次
X{n}	X{n}?	X{n}+	X表达式出现 n 次
X{n,}	X{n,}?	X{n,}+	X表达式最少出现 n 次
X{n,m}	X{n,m}?	X{n,m}+	X表达式最少出现 n 次，最多出现 m 次

java.util.regex 是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包，包括两个类：Pattern 和 Matcher
Pattern 对象是正则表达式编译后在内存中的表示形式，再利用该 Pattern 对象创建对应的 Matcher 对象。
执行匹配所涉及的状态保留在 Matcher 对象中，多个 Matcher 对象可共享同一个 Pattern 对象
        // 将一个字符串编译成 Pattern 对象: Pattern.compile(String regex);
        Pattern p = Pattern.compile("a*b");
        // 使用 Pattern 对象创建 Matcher 对象
        Matcher m = p.matcher("aaaaaab"); //传入要进行匹配的字符串
        System.out.println(m.matches()); // 返回 true

Matcher 类常用方法：
find()	    返回目标字符串中是否包含与 Pattern 匹配的子串
group()	    返回上一次与 Pattern 匹配的子串
start()	    返回上一次与 Pattern 匹配的子串在目标字符串中的开始位置
end()	    返回上一次与 Pattern 匹配的子串在目标字符串中的结束位置加 1
lookingAt()	返回目标字符串前面部分与 Pattern 是否匹配   lookingAt() 只要字符串以 Pattern 开头就会返回 true
matches()	返回整个目标字符串与 Pattern 是否匹配       matches() 方法要求整个字符串和 Pattern 完全匹配时才返回 true
reset()	    将现有的 Matcher 对象应用于一个新的字符序列




