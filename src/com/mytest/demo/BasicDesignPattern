单例模式:
Ensure a class has only one instance, and provide a global point of access to it.
确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例）




观察者模式：在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新

观察者模式UML图：
  <interface> Subject             <--------注册--------               <interface> Observer
+ addObserver(Observer o)                                               + update()
+ deleteObserver(Observer o)
+ notifyObserver()
         ^                                                                     ^
         |                                                                     |
  实现类 ConcreteSubject           --------注册-------->               实现类 ConcreteObserver
Subject： 观察主题对象，也可以叫被观察或者被订阅对象
Observer： 观察者或者订阅者对象，当Subject有变动，就会通知到每一个Observer




装饰者模式（Decorator）：在不改变原有对象的基础之上，将功能附加到对象上。提供了比继承更有弹性的替代方案（扩展原有对象功能）

类型：结构型

适用场景：
1、扩展一个类的功能或者给一个类添加附加职责
2、给一个对象动态的添加功能，或动态撤销功能

优点：
1、继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能
 （继承在扩展功能是静态的，必须在编译时就确定好，而使用装饰者可以在运行时决定，装饰者也建立在继承的基础之上的）
2、通过使用不同装饰类以及这些类的排列组合，可以实现不同的效果
3、符合开闭原则
缺点：
1、会出现更多的代码，更多的类，增加程序的复杂性。
2、动态装饰时，多层装饰时会更复杂（使用继承来拓展功能会增加类的数量，使用装饰者模式不会像继承那样增加那么多类的数量，
   但是会增加对象的数量，当对象的数量增加到一定的级别时，无疑会大大增加我们代码调试的难度）

装饰者和代理模式：
装饰者模式关注的是对象的动态添加功能。代理模式关注的是对对象的控制访问，对它的用户隐藏对象的具体信息

装饰者模式和适配器模式：
装饰者模式和被装饰的类要实现同一个接口，或者装饰类是被装饰的类的子类。 适配器模式和被适配的类具有不同的接口




适配器模式：将一个类的接口转成客户期望的另外一个接口。适配器模式使得原本由于接口不匹配而不能一起工作的那些类可以一起工作

Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。
Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对 Adaptee 和 Target 进行适配，适配器类是适配器模式的核心，
                   在对象适配器中，通过继承 Target 并关联一个 Adaptee 对象使二者产生联系。
Adaptee（适配者类）：适配者即被适配的角色，定义一个已经存在的接口，该接口需要适配，
                   适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码

适配器实现方式分三类：
对象适配器模式：适配器与适配者之间是关联关系
类适配器模式：  适配器与适配者之间是继承关系
接口适配器模式：适配器与适配者之间是实现关系




工厂模式（Factory）：
1、普通（简单）工厂模式：一个工厂类，对实现同一接口的一些类进行实例的创建
2、多个工厂方法模式：在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象
3、静态工厂方法模式：将多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用
4、抽象工厂模式（Abstract Factory）：创建多个工厂类，一旦需要增加新的功能，直接增加新的工厂类，不需要修改之前的代码




代理模式（proxy）：静态代理和动态代理
静态代理：由程序员创建或特定工具自动生成源代码，再对其进行编译。在程序运行之前，代理类.class文件就已经被创建，
         代理类和委托类的关系在运行前就确定。
动态代理：动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，不存在代理类的字节码文件。
        代理类和委托类的关系是在程序运行时确定
        注：动态代理类只能代理接口

Subject 抽象主题角色：可以是抽象类，也可以是接口。抽象主题是一个普通的业务类型，无特殊要求。
RealSubject 具体主题角色：也叫做被委托角色或被代理角色，是业务逻辑的具体执行者。
Proxy 代理主题角色：也叫做委托类或代理类。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，
                  并且在具体主题角色处理完毕前后做预处理和善后处理工作



